server.port=9998
processor.default.url=http://localhost:8001
processor.fallback.url=http://localhost:8002
# Conexão com o Redis que está rodando no contêiner do docker-compose.dev.yml
# --- CONFIGURAÇÃO DO REDIS ---
# Diz ao Spring para usar o Jedis como o cliente de conexão.
spring.data.redis.client-type=JEDIS

# Configurações do pool de conexões (agora para o Jedis)
spring.data.redis.jedis.pool.max-active=${REDIS_POOL_MAX_ACTIVE:256}
spring.data.redis.jedis.pool.max-idle=${REDIS_POOL_MAX_IDLE:32}
spring.data.redis.jedis.pool.min-idle=${REDIS_POOL_MIN_IDLE:8}
spring.data.redis.jedis.pool.max-wait=${REDIS_POOL_MAX_WAIT:-1ms}
spring.data.redis.host=localhost
spring.data.redis.port=6379


# --- NÍVEIS DE LOG ---
logging.level.root=INFO
logging.level.br.dev.felipeschirmann.rinha=INFO
logging.level.reactor.netty=WARN
logging.level.io.netty=WARN
# Mas liga o canal de rastreamento de pagamentos para ver todos os detalhes
#logging.level.PaymentTrace=DEBUG
logging.level.PaymentTrace=OFF

# Tamanho máximo da fila de pagamentos em memória.
rinha.queue.max-size=${RINHA_QUEUE_MAX_SIZE:50000}
rinha.queue.fallback-trigger-size=${RINHA_QUEUE_FALLBACK_TRIGGER_SIZE:3000}

# Número de threads no pool de consumidores (se usar newFixedThreadPool)
# Para Virtual Threads, este valor não é usado, mas mantemos para flexibilidade.
rinha.executor.consumer-threads=${RINHA_EXECUTOR_CONSUMER_THREADS:100}

# --- CONFIGURAÇÃO DO MONITOR DE MEMÓRIA ---
rinha.memory-monitor.reporting-threshold-mb=${RINHA_MEMORY_MONITOR_REPORTING_THRESHOLD_MB:50}
rinha.memory-monitor.initial-delay-sec=${RINHA_MEMORY_MONITOR_INITIAL_DELAY_SEC:5}
rinha.memory-monitor.period-sec=${RINHA_MEMORY_MONITOR_PERIOD_SEC:5}

# --- CONFIGURAÇÃO DOS CLIENTES HTTP (AJUSTE CRÍTICO DE VAZÃO) ---
# Número máximo de conexões no pool (usado pelo RestClient e WebClient).
rinha.webclient.max-connections=${RINHA_WEBCLIENT_MAX_CONNECTIONS:700}
rinha.webclient.pending-acquire-max-count=${RINHA_WEBCLIENT_PENDING_ACQUIRE_MAX_COUNT:500}
rinha.webclient.connect-timeout-ms=${RINHA_WEBCLIENT_CONNECT_TIMEOUT_MS:2000}
rinha.webclient.response-timeout-sec=${RINHA_WEBCLIENT_RESPONSE_TIMEOUT_SEC:10}

# --- CONFIGURAÇÃO DO BATCHING PARA O REDIS ---
# Frequência (em ms) com que os pagamentos são escritos em lote no Redis.
rinha.scheduler.redis-batch-period-ms=${RINHA_SCHEDULER_REDIS_BATCH_PERIOD_MS:100}
rinha.scheduler.strategyDecisionPeriodMs=${RINHA_STRATEGY_DECISION_PERIOD_MS:5000}

rinha.processor.fallback-tolerance-ms=${RINHA_PROCESSOR_FALLBACK_TOLERANCE_MS:1500}
rinha.processor.health-data-max-age-ms=${RINHA_PROCESSOR_HEALTH_DATA_MAX_AGE_MS:4500}

# Número de falhas de health check CONSECUTIVAS necessárias para
# considerar um processador offline e mudar a estratégia.
rinha.processor.failure-threshold=${RINHA_PROCESSOR_FAILURE_THRESHOLD:5}


# --- CONFIGURAÇÃO DO CIRCUIT BREAKER (DISJUNTOR) ---
# Controla o comportamento de resiliência para cada processador.

# Para o Processador Default
# Se 50% das últimas 50 chamadas falharem, o circuito abre.
rinha.processor.failure-threshold.default=${RINHA_PROCESSOR_FAILURE_THRESHOLD_DEFAULT:5}
resilience4j.circuitbreaker.instances.default-processor.failure-rate-threshold=${RINHA_CB_DEFAULT_FAILURE_RATE:50}
resilience4j.circuitbreaker.instances.default-processor.sliding-window-size=${RINHA_CB_DEFAULT_WINDOW_SIZE:50}
# Quando o circuito abrir, ele ficará aberto por 5 segundos antes de tentar de novo.
resilience4j.circuitbreaker.instances.default-processor.wait-duration-in-open-state=${RINHA_CB_DEFAULT_WAIT_DURATION:5s}
# O tipo de janela de observação. COUNT_BASED é o ideal para este cenário.
resilience4j.circuitbreaker.instances.default-processor.sliding-window-type=COUNT_BASED
# Quantas chamadas são permitidas no estado "meio-aberto" para testar a recuperação.
resilience4j.circuitbreaker.instances.default-processor.permitted-number-of-calls-in-half-open-state=${RINHA_CB_DEFAULT_HALF_OPEN_CALLS:5}


# Para o Processador Fallback
# Se 50% das últimas 50 chamadas falharem, o circuito abre.
rinha.processor.failure-threshold.fallback=${RINHA_PROCESSOR_FAILURE_THRESHOLD_FALLBACK:1}
resilience4j.circuitbreaker.instances.fallback-processor.failure-rate-threshold=${RINHA_CB_FALLBACK_FAILURE_RATE:50}
resilience4j.circuitbreaker.instances.fallback-processor.sliding-window-size=${RINHA_CB_FALLBACK_WINDOW_SIZE:50}
# Quando o circuito abrir, ele ficará aberto por X segundos antes de tentar de novo.
resilience4j.circuitbreaker.instances.fallback-processor.wait-duration-in-open-state=${RINHA_CB_FALLBACK_WAIT_DURATION:30s}
# O tipo de janela de observação.
resilience4j.circuitbreaker.instances.fallback-processor.sliding-window-type=COUNT_BASED
# Quantas chamadas são permitidas no estado "meio-aberto".
resilience4j.circuitbreaker.instances.fallback-processor.permitted-number-of-calls-in-half-open-state=${RINHA_CB_FALLBACK_HALF_OPEN_CALLS:2}