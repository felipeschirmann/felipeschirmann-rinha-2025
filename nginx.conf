worker_processes auto;

events {
    worker_connections 4096;
    multi_accept on;
    use epoll;
}

http {
#     access_log off;

 # Para depurar, vamos enviar os logs para a saída padrão do container
    # Assim eles aparecem com 'docker-compose logs'
    access_log /dev/stdout;
    error_log /dev/stderr warn; # Loga apenas avisos e erros
    # O resolver é necessário para que o Lua consiga encontrar o serviço 'redis' na rede do Docker.
    resolver 127.0.0.11 valid=5s;

    # Criamos um pool com nossas duas APIs Java.
    # Este pool será usado APENAS para o endpoint de sumário.
    upstream java_apis {
        server api01:9998;
        server api02:9998;
        keepalive 32;
    }

    server {
        listen 9999;

        tcp_nodelay on;
        tcp_nopush on;

        # --- ROTA DE ALTA PERFORMANCE PARA ENFILEIRAR PAGAMENTOS ---
        location = /payments {
            # Permite apenas o método POST
            if ($request_method != POST) {
                return 405; # Method Not Allowed
            }
            # Executa nosso script Lua para enfileirar no Redis e responder 202
            content_by_lua_file /usr/local/openresty/nginx/scripts/enqueue_payment.lua;
        }

        # --- ROTA PARA O SUMÁRIO, ATENDIDA PELAS APIS JAVA ---
        location = /payments-summary {
            proxy_pass http://java_apis;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
        }

        # --- ROTA PARA LIMPEZA (PURGE), TAMBÉM ATENDIDA PELAS APIS ---
        location = /purge-payments {
             if ($request_method != POST) {
                return 405;
            }
            proxy_pass http://java_apis;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
        }
    }
}